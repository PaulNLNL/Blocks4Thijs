<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Thijs Blocks</title>
  <style>
    /* Reset and disable scrolling/touch callout */
    html, body {
      margin: 0;
      padding: 0;
      touch-action: none;
      overscroll-behavior: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      height: 100%;
    }
    /* Layout: header at top, main grows, footer at bottom */
    body {
      display: flex;
      flex-direction: column;
      font-family: sans-serif;
      background: #334;
      color: #fff;
    }
    header {
      flex: 0 0 auto;
      text-align: center;
      padding: 10px;
    }
    main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    footer {
      flex: 0 0 auto;
      text-align: center;
      padding: 10px;
    }
    /* Score area in header */
    #score {
      font-size: 1.2rem;
      margin-top: 5px;
    }
    /* Responsive board: square, maximized within viewport */
    #board {
      width: calc(min(90vw, 80vh));
      height: calc(min(90vw, 80vh));
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-gap: 2px;
      border: 2px solid #222;
      background-color: #222;
      position: relative;
    }
    .cell {
      width: 100%;
      height: 100%;
      background-color: #555;
      border-radius: 4px;
    }
    /* Flash animation for cleared rows/columns */
    .flash {
      animation: flashAnim 300ms;
    }
    @keyframes flashAnim {
      0% { background-color: #fff; }
      50% { background-color: #fff; }
      100% { background-color: #555; }
    }
    /* Shapes container (below board) */
    #shapes-container {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .shape {
      background-color: transparent;
      user-select: none;
      transition: transform 0.3s;
    }
    .shape.draggable { cursor: grab; }
    .shape:active { cursor: grabbing; }
    /* The individual block cells inside shapes – size will be set via JS */
    .shape-cell {
      display: inline-block;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: inset 0 -2px 3px rgba(0,0,0,0.3),
                  0 1px 2px rgba(0,0,0,0.2);
      margin: 1px;
    }
    /* Brighter color palette with 3D bevel (applied for board cells and preview) */
    .color1 { background-color: #FF6B6B; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color2 { background-color: #FFD93D; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color3 { background-color: #6BCB77; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color4 { background-color: #4D96FF; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color5 { background-color: #B983FF; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color6 { background-color: #FF9F1C; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    .color7 { background-color: #2EC4B6; border: 1px solid rgba(255,255,255,0.2); 
              box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); }
    /* Preview blocks on board – will use dynamically computed size */
    .preview-block {
      position: absolute;
      opacity: 0.6;
      border: 1px solid rgba(255,255,255,0.6);
      box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4),
                  0 2px 3px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .preview-block.invalid {
      border-color: red;
    }
    /* Restart button in footer */
    #restartButton {
      padding: 8px 16px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background-color: #4D96FF;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #restartButton:hover {
      background-color: #3B7DDD;
    }
  </style>
</head>
<body>

  <header>
    <h1>Thijs Blocks</h1>
    <div id="score">Score: <span id="scoreValue">0</span> | High Score: <span id="highScoreValue">0</span></div>
  </header>

  <main>
    <div id="board"></div>
    <div id="shapes-container"></div>
  </main>

  <footer>
    <button id="restartButton">Restart Game</button>
  </footer>

  <script>
    // Prevent default touchmove (for mobile) so the page does not scroll.
    document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    // Constants for grid and gap
    const NUM_CELLS = 8, GAP = 2;
    const board = [];
    let score = 0, highScore = 0;
    let currentDraggingShape = null, currentDraggingId = null;

    const boardDiv = document.getElementById('board');
    const shapesContainer = document.getElementById('shapes-container');
    const scoreValue = document.getElementById('scoreValue');
    const highScoreValue = document.getElementById('highScoreValue');

    // Our SHAPES array (same as before)
    const SHAPES = [
      { blocks: [[1]], color: 'color1' },
      { blocks: [[1,1]], color: 'color2' },
      { blocks: [[1],[1]], color: 'color3' },
      { blocks: [[1,1],[1,1]], color: 'color4' },
      { blocks: [[1,1,1],[0,1,0]], color: 'color5' },
      { blocks: [[1,1,1,1]], color: 'color6' },
      { blocks: [[1],[1],[1],[1]], color: 'color7' },
      { blocks: [[1,1,1,1,1]], color: 'color1' },
      { blocks: [[1],[1],[1],[1],[1]], color: 'color2' },
      { blocks: [[1,1,1],[1,1,1],[1,1,1]], color: 'color3' },
      { blocks: [[1,0],[1,0],[1,1]], color: 'color4' },
      { blocks: [[0,1],[0,1],[1,1]], color: 'color5' },
      { blocks: [[1,1,0],[0,1,1]], color: 'color6' },
      { blocks: [[0,1,1],[1,1,0]], color: 'color7' },
      { blocks: [[1,0,0],[1,0,0],[1,1,0]], color: 'color1' },
      { blocks: [[1,1,1],[1,0,0],[0,0,0]], color: 'color2' },
      { blocks: [[1,1,0],[0,1,0],[0,1,0]], color: 'color3' },
      { blocks: [[0,0,1],[1,1,1],[0,0,0]], color: 'color4' }
    ];

    // Initialize board array
    for (let r = 0; r < NUM_CELLS; r++) {
      board[r] = [];
      for (let c = 0; c < NUM_CELLS; c++) {
        board[r][c] = 0;
      }
    }

    // Create board cells (the grid cells are created by CSS Grid, but we add divs with id)
    for (let r = 0; r < NUM_CELLS; r++) {
      for (let c = 0; c < NUM_CELLS; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.id = `cell-${r}-${c}`;
        cell.addEventListener('dragenter', e => { e.preventDefault(); });
        cell.addEventListener('dragover', e => {
          e.preventDefault();
          updatePreview(r, c);
        });
        cell.addEventListener('dragleave', e => { clearPreview(); });
        cell.addEventListener('drop', onDrop);
        boardDiv.appendChild(cell);
      }
    }
    boardDiv.addEventListener('dragleave', e => {
      if (!boardDiv.contains(e.relatedTarget)) clearPreview();
    });

    generateShapes();
    document.getElementById('restartButton').addEventListener('click', resetGame);

    // Utility: compute current cell size (based on board's computed width)
    function getCellSize() {
      // boardDiv.offsetWidth equals the board's width (which we set via CSS)
      return (boardDiv.offsetWidth - (NUM_CELLS - 1) * GAP) / NUM_CELLS;
    }

    function onDrop(e) {
      e.preventDefault();
      clearPreview();
      const shapeId = e.dataTransfer.getData('text');
      const shapeObj = window.currentShapes[shapeId];
      if (!shapeObj) return;
      // Determine drop cell from event target's id
      const parts = e.target.id.split('-');
      const row = parseInt(parts[1]), col = parseInt(parts[2]);
      if (canPlaceShape(row, col, shapeObj)) {
        placeShape(row, col, shapeObj);
        const shapeDiv = document.getElementById(shapeId);
        shapesContainer.removeChild(shapeDiv);
        delete window.currentShapes[shapeId];
        checkAndClearLines();
        updateScore();
        if (Object.keys(window.currentShapes).length === 0) generateShapes();
      }
      currentDraggingShape = null;
      currentDraggingId = null;
    }

    function canPlaceShape(row, col, shapeObj) {
      const blocks = shapeObj.blocks;
      for (let r = 0; r < blocks.length; r++) {
        for (let c = 0; c < blocks[r].length; c++) {
          if (blocks[r][c] === 1) {
            const br = row + r, bc = col + c;
            if (br < 0 || br >= NUM_CELLS || bc < 0 || bc >= NUM_CELLS) return false;
            if (board[br][bc] !== 0) return false;
          }
        }
      }
      return true;
    }

    function placeShape(row, col, shapeObj) {
      const blocks = shapeObj.blocks;
      for (let r = 0; r < blocks.length; r++) {
        for (let c = 0; c < blocks[r].length; c++) {
          if (blocks[r][c] === 1) {
            const br = row + r, bc = col + c;
            board[br][bc] = shapeObj.color;
            const cellDiv = document.getElementById(`cell-${br}-${bc}`);
            cellDiv.classList.add(shapeObj.color);
          }
        }
      }
      const placedCount = blocks.reduce((sum, arr) => sum + arr.reduce((s, v) => s + v, 0), 0);
      score += placedCount;
    }

    // Flash animation for full rows/columns
    function checkAndClearLines() {
      for (let r = 0; r < NUM_CELLS; r++) {
        if (board[r].every(cell => cell !== 0)) {
          for (let c = 0; c < NUM_CELLS; c++) {
            document.getElementById(`cell-${r}-${c}`).classList.add('flash');
          }
          setTimeout(() => {
            board[r] = Array(NUM_CELLS).fill(0);
            for (let c = 0; c < NUM_CELLS; c++) {
              document.getElementById(`cell-${r}-${c}`).className = 'cell';
            }
            score += NUM_CELLS;
            updateScore();
          }, 300);
        }
      }
      for (let c = 0; c < NUM_CELLS; c++) {
        let colFull = true;
        for (let r = 0; r < NUM_CELLS; r++) {
          if (board[r][c] === 0) { colFull = false; break; }
        }
        if (colFull) {
          for (let r = 0; r < NUM_CELLS; r++) {
            document.getElementById(`cell-${r}-${c}`).classList.add('flash');
          }
          setTimeout(() => {
            for (let r = 0; r < NUM_CELLS; r++) {
              board[r][c] = 0;
              document.getElementById(`cell-${r}-${c}`).className = 'cell';
            }
            score += NUM_CELLS;
            updateScore();
          }, 300);
        }
      }
    }

    function updateScore() { scoreValue.textContent = score; }
    function updateHighScore() { highScoreValue.textContent = highScore; }

    // Generate three random shapes
    function generateShapes() {
      window.currentShapes = {};
      for (let i = 0; i < 3; i++) {
        const randomIndex = Math.floor(Math.random() * SHAPES.length);
        const shapeData = JSON.parse(JSON.stringify(SHAPES[randomIndex]));
        const shapeId = 'shape-' + Date.now() + '-' + i;
        window.currentShapes[shapeId] = shapeData;
        const shapeDiv = renderShape(shapeData, shapeId);
        shapesContainer.appendChild(shapeDiv);
      }
    }

    // Render shape for the shapes container. Their block size is set relative to board cell size.
    function renderShape(shapeObj, shapeId) {
      const shapeDiv = document.createElement('div');
      shapeDiv.className = 'shape draggable';
      shapeDiv.id = shapeId;
      shapeDiv.draggable = true;
      shapeDiv.addEventListener('dragstart', function(e) {
        currentDraggingShape = shapeObj;
        currentDraggingId = shapeId;
        e.dataTransfer.setData('text', shapeId);
        const transparentImg = document.createElement('canvas');
        transparentImg.width = 1; transparentImg.height = 1;
        e.dataTransfer.setDragImage(transparentImg, 0, 0);
      });
      shapeDiv.addEventListener('dragend', function(e) {
        clearPreview();
        currentDraggingShape = null;
        currentDraggingId = null;
      });
      // Add touch event handlers for mobile
      shapeDiv.addEventListener("touchstart", onTouchStart, false);
      shapeDiv.addEventListener("touchmove", onTouchMove, false);
      shapeDiv.addEventListener("touchend", onTouchEnd, false);

      // Compute shape cell size: 0.625 of board cell size
      const shapeCellSize = getCellSize() * 0.625;
      const blocks = shapeObj.blocks;
      for (let r = 0; r < blocks.length; r++) {
        const rowDiv = document.createElement('div');
        rowDiv.style.display = 'flex';
        for (let c = 0; c < blocks[r].length; c++) {
          const blockCell = document.createElement('div');
          blockCell.className = 'shape-cell';
          blockCell.style.width = shapeCellSize + "px";
          blockCell.style.height = shapeCellSize + "px";
          if (blocks[r][c] === 1) {
            blockCell.classList.add(shapeObj.color);
          } else {
            blockCell.style.visibility = 'hidden';
          }
          rowDiv.appendChild(blockCell);
        }
        shapeDiv.appendChild(rowDiv);
      }
      return shapeDiv;
    }

    // --- Mobile touch event handlers ---
    function onTouchStart(e) {
      e.preventDefault();
      currentDraggingShape = window.currentShapes[e.currentTarget.id];
      currentDraggingId = e.currentTarget.id;
    }
    function onTouchMove(e) {
      e.preventDefault();
      if (!currentDraggingShape) return;
      const touch = e.touches[0];
      const boardRect = boardDiv.getBoundingClientRect();
      const x = touch.clientX, y = touch.clientY;
      if (x >= boardRect.left && x <= boardRect.right && y >= boardRect.top && y <= boardRect.bottom) {
        const relativeX = x - boardRect.left;
        const relativeY = y - boardRect.top;
        const cellSize = getCellSize();
        const col = Math.floor(relativeX / (cellSize + GAP));
        const row = Math.floor(relativeY / (cellSize + GAP));
        updatePreview(row, col);
      } else {
        clearPreview();
      }
    }
    function onTouchEnd(e) {
      e.preventDefault();
      clearPreview();
      if (!currentDraggingShape) return;
      const touch = e.changedTouches[0];
      const boardRect = boardDiv.getBoundingClientRect();
      const x = touch.clientX, y = touch.clientY;
      if (x >= boardRect.left && x <= boardRect.right && y >= boardRect.top && y <= boardRect.bottom) {
        const relativeX = x - boardRect.left;
        const relativeY = y - boardRect.top;
        const cellSize = getCellSize();
        const col = Math.floor(relativeX / (cellSize + GAP));
        const row = Math.floor(relativeY / (cellSize + GAP));
        if (canPlaceShape(row, col, currentDraggingShape)) {
          placeShape(row, col, currentDraggingShape);
          const shapeDiv = document.getElementById(currentDraggingId);
          shapesContainer.removeChild(shapeDiv);
          delete window.currentShapes[currentDraggingId];
          checkAndClearLines();
          updateScore();
          if (Object.keys(window.currentShapes).length === 0) generateShapes();
        }
      }
      currentDraggingShape = null;
      currentDraggingId = null;
    }
    // --- End Mobile Handlers ---

    // Create preview overlay on board using computed cell size
    function updatePreview(startRow, startCol) {
      clearPreview();
      if (!currentDraggingShape) return;
      const valid = canPlaceShape(startRow, startCol, currentDraggingShape);
      const cellSize = getCellSize();
      const blocks = currentDraggingShape.blocks;
      for (let r = 0; r < blocks.length; r++) {
        for (let c = 0; c < blocks[r].length; c++) {
          if (blocks[r][c] === 1) {
            const targetRow = startRow + r, targetCol = startCol + c;
            if (targetRow < 0 || targetRow >= NUM_CELLS || targetCol < 0 || targetCol >= NUM_CELLS) continue;
            const preview = document.createElement('div');
            preview.className = 'preview-block';
            if (!valid) preview.classList.add('invalid');
            preview.style.width = cellSize + "px";
            preview.style.height = cellSize + "px";
            preview.style.left = (targetCol * (cellSize + GAP)) + "px";
            preview.style.top = (targetRow * (cellSize + GAP)) + "px";
            preview.style.backgroundColor = getColor(currentDraggingShape.color);
            boardDiv.appendChild(preview);
          }
        }
      }
    }
    function clearPreview() {
      document.querySelectorAll('.preview-block').forEach(el => el.parentNode.removeChild(el));
    }
    function getColor(colorClass) {
      switch(colorClass) {
        case 'color1': return '#FF6B6B';
        case 'color2': return '#FFD93D';
        case 'color3': return '#6BCB77';
        case 'color4': return '#4D96FF';
        case 'color5': return '#B983FF';
        case 'color6': return '#FF9F1C';
        case 'color7': return '#2EC4B6';
        default: return '#ffffff';
      }
    }
    // Restart game: update high score if needed, clear board, reset score, and generate new shapes.
    function resetGame() {
      if (score > highScore) { highScore = score; updateHighScore(); }
      score = 0; updateScore();
      for (let r = 0; r < NUM_CELLS; r++) {
        for (let c = 0; c < NUM_CELLS; c++) {
          board[r][c] = 0;
          document.getElementById(`cell-${r}-${c}`).className = 'cell';
        }
      }
      shapesContainer.innerHTML = '';
      generateShapes();
    }
  </script>
</body>
</html>
